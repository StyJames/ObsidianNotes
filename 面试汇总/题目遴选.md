# Java
1. 聊聊Java的NIO
	1. NIO是非阻塞IO，他被设计成高效并且面向块的IO方式，是针对原来BIO即阻塞式IO的一种更高效的设计。NIO提供了的Buffer来作为缓冲区，抽象出来一个Selector来作为网络、文件交互的总线，或者叫多路复用器。并将网络套间字、文件等原来的Socket抽象为一个个的双向全双工Channel或者叫通道。
	2. 交互的大体过程，首先按需选择网络、文件等的channel抽象实现，进行初始化，并注册到对应的Selector上,如果该channel有新的文件或者链接，就会设置selectKey状态为就绪。同时selector会对已经注册并就绪的channel进行轮询，然后通过Buffer来发送数据流。
	3. 后续JDK7，针对NIO提供了异步的设计
2. 谈谈JVM
	1. JVM是Java一次书写到处运行的基础，它帮助开发者屏蔽了底层硬件专注于代码开发。并且提供了GC机制，来帮助开发者进行内存回收，也使得Java更易于作为服务器长时间稳定的运行。
	2. JVM在内存中开辟了一套专有的数据空间。分为堆,方法区，虚拟机栈，本地方法栈，PC计数器。其中GC的主要对象是堆。
		1. 堆又分为新生代和老年代，所有的对象和数组都在这里进行初始化
		2. 方法区有常量池缓存数据，加载的类信息以及JIT优化的编译后代码等
		3. 虚拟机栈存储的是每一次方法调用的栈帧，栈帧内是方法内基本信息、变量表等
		4. 本地方法栈存储的是Java调用偏底层的native方法一般是C、C++实现，在Java中一条方法调用
		5. PC计数器存放的是当前线程正在运行方法的JVM地址
	3. JVM整体包含类加载系统、执行引擎、运行时数据区（其中运行时数据区最多考量）
3. 类加载机制

# MySQL

1. 谈谈MySQL的隔离级别，四种均可选，默认是读已提交
	1. 读未提交，没有任何锁策略，可以读取未提交事务的更新
	2. 读已提交，仅能读到其他事务已经提交的更新，解决脏读，即一个事务读取了另一个事务未提交的数据。
	3. 可重复读-Oracle默认，一个事务连续两次读到的同一数据是一致的，可解决不可重复读，即一个事务前后针对同一个数据读到不同的值
	4. 串行化，对表增加共享排它锁，只能读不能写，所有事物串行，可解决幻读
2. 脏读幻读不可重复度的相关描述，不可重复读侧重于修改，幻读侧重于新增或删除（多了或少量行），脏读是一个事务回滚影响另外一个事务。
	1. 脏读，事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据
	2. 不可重复读，事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果 不一致。
	3. 幻读，系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。
3. MySQL事务的实现，基于redolog和undolog的。每提交一个事务必须先将该事务的所有日志写入到重做日志文件进行持久化，数据库就可以通过重做日志来保证事务的原子性和持久性。每当有修改事务时，还会产生 undo log，如果需要回滚，则根据 undo log 的反向语句进行逻辑操作，比如 insert 一条记录就 delete 一条记录。undo log 主要实现数据库的一致性。
4. redolog和undolog
5. MySQL的 binlog 是什么，记录所有数据库表结构变更（例如 CREATE、ALTER TABLE）以及表数据修改（INSERT、UPDATE、DELETE）的二进制日志.