# 线程安全
1. 原子性，保证线程操作的连续性，不会被其他线程打扰，通过同步方法保证
2. 可见性，保证共享变量被修改之后可以立即被其他线程感知，将线程本地变量反映到主内存中，一般采用volatile关键字来保证
3. 有序性，禁止指令重排，保证指令串行

# 线程死锁
多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放，并且没有外部介入是无法自动解除的。
## 线程死锁的条件
1. 互斥条件，该资源任意时刻仅有一个线程占用
2. 请求与保持条件，一个线程因为请求资源而阻塞，但是对已经获取的资源却没有释放
3. 不剥夺条件，线程已获得资源在没有使用完的时候是没法释放的
4. 循环等待，若干已阻塞的线程之前形成头尾相衔的循环等待资源的关系
## 避免线程死锁
破坏死锁形成的条件即可。
1. 一次性申请所有的资源
2. 占用部分资源的线程在一段时间获取不到资源可以考虑释放已经占有的资源，进行退避等待
3. 所有的线程都按照一定的顺序进行资源的获取，同时释放资源时，按照相反的顺序释放
# synchronized、volatile、reentraintLock
1. synchronized是Java的保留字，提供了锁的功能，保证互斥和可见性。当一个线程已经获取到锁的时候，其余线程只能等待、阻塞
	1. JDK早期版本的synchronized关键字的实现是在，保证同时仅有一个线程能够执行这一串代码，这个锁依赖于操作系统的实现。所以会在使用中进行操作系统内核态和用户态的上下文切换。导致在线程并发提高之后性能劣化严重，效率并没有Java提供的Lock/ReentrantLock高。
	2. synchronized之后的优化，为了减小在加锁、解锁的上带来的消耗引入了无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，并且锁的标志位都位于对象头
		1. 偏向锁是假定当前无竞争，尽量减少轻量级锁的多次[CAS操作](CAS与AQS.md)的设计，仅在对象头切换线程ID时候会有一次CAS操作，但是如果存在竞争则会立即撤回偏向锁并进行锁的升级
		2. 轻量级锁的设计是为了减少使用传统重量级锁带来的性能开销。
	3. synchronized的使用一般有三种
		1. 修饰实例方法，是给当前对象加锁
		2. 修饰静态方法，是给对应的class加锁
		3. 修饰代码块，看具体场景锁住的是对象还是类，是与1/2相同的锁内容
	4. synchronized针对代码块的同步是在代码块的首尾加上monitor锁（monitor.enter/monitor.exit），针对方法的同步是加上了
2. ReentrantLock是JUC包中提供的锁,也叫做可重入锁，底层换个 提供了公平性的选择。也提供了条件方法`condition`，存在更多操作方法，比synchronized更加细粒度的操作。但是需要lock/unlock成对出现来保证加锁和释放锁。
	1. 比synchronized操作粒度更细致，等待可中断、可实现公平锁、可实现条件通知
	2. 只能锁住代码块

3. `volatile`解决的是内存的可见性，被volatile修饰的变量读写都是直接在主存操作。保证所有线程对该变量的可见性。volatile仅能作用于变量，并且被修饰的变量不会被编译器优化

# JUC-java.util.concurrency
1. Java本身提供的线程同步工具粒度较为粗放。比如普通集合类中自带同步的工具vector/hashTable等，以及collection包提供的同步包装，它将所有操作方法加上了synchronized关键字来满足同步需求。但是在并发度较为高的场景下，需要一个更加同步粒度更为细致的方案，即concurrency包。
2. concurrency包提供的线程安全容器：![](791750d6fe7ef88ecb3897e1d029f079.webp)
	1. 各种并发容器，可以按照名称分类，Concurrent*、CopyOnWrite和 Blocking等三类。ConcurrenctHashMap、CopyOnWriteArrayList
	2. 线程安全队列（queue、deque），ArrayBlockingQueue、SynchronousQueue
	3. 各种有序容器的线程安全版本
3. ConcurrenctHashMap举例分析
	1. 整体上仍然是数组+链表元素的复合结构，segment仅作为一个兼容性的东西，不再实际使用。key设置为final，保证一致不变，value设置为volatile保证可见性，同时链表也设置为volatile保证可见性。如下展示节点的部分属性：
	 ```java
	 static class Node<K,V> implements Map.Entry<K,V> {`
        `final int hash;`
        `final K key;`
        `volatile V val;`
        `volatile Node<K,V> next;`
        `// …` 
    `}`
```
	2. 使用[CAS操作](CAS与AQS)，保证大部分场景的无锁并发。极端情况下采用Unsafe、LongAdder等底层JNI调用来保证并发。

# ThreadLocal
线程本地变量，每个线程维护一份。隔离其他线程访问，也是一种线程安全的实现。
1. 应用场景：数据库连接池，会话中保存一些用户信息等
2. 因为ThreadLocalMap的key是弱引用类型，只要出现GC，就会被回收，但是此处的Value可能还是有效状态，这样就造成了内存泄漏。所以需要在代码中显式的进行释放`remove()`
3. 