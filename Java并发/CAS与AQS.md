# CAS 
1. 比较并替换，一条CPU同步原语，是Java中的unsafe方法，使用C++编写的用来实现底层CPU并发场景下数据同步的原子操作，用来管理对并发数据的共享访问，属于无锁的实现。
2. CAS的操作：
	1. 所需三个值，需要读写的值K，内存旧值A，期望修改的更新值B
	2. 当且仅当K=A的情况下，CAS用B来更新K的值，否则不执行任何操作，一般自旋等待
3. CAS存在的问题
	1. ABA问题，高并发场景下，可能数据已经经过了A->B->A的修改，此时虽然满足了CAS的条件，但是可能仍然存在数据问题。此种情况一般增加版本号或者时间戳来额外保证数据的一致性。比如使用 `AtomicStampedReference`
	2. 循环时间开销大，当不满足K=A的条件下，会进行自旋等待，不然CPU的无谓开销会增多。这个最大自旋次数可以通过JVM参数来进行调整。提供了`-XX:+UseSpinning`参数来开启自旋锁，使用`-XX:PreBlockSpin`参数来设置自旋锁的等待次数
	3. CAS仅保证一个变量的操作是原子性的，多变量的场景需要额外的并发手段来保证同步。解决方案可以采用互斥锁，或者将多个变量封装成对象，使用`AtomicReference`包装起来，保证原子性
	
# AQS-AbstractQueuedSynchronizer
一个抽象的队列同步器，结构如下所示：
1. 一个volatile的变量State表征状态，
2. 一个等待线程队列，以实现多线程竞争，AQS的核心
3. 各种基于CAS的基础操作，以及各种期望同步结构去实现的acquire、release方法。利用AQS实现一个同步队列，至少需要实现对应的acquire、release方法，来保证对于资源的独占、释放。
具体同步过程如下：
1. 首先判断State的状态是否=0，为零代表无争抢，可直接CAS获取
2. 非0状态代表有竞争，需要线程入等待队列进行等待
3. 等待队列的当前节点前一个节点如果是头节点，则进行锁的获取，获取成功就进行出队操作，并将当前节点放置在头结点，否则继续等待