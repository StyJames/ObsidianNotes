# 数据库结构
## 数据库集簇 database cluster
即一堆数据库对象的集合，由一个服务端统一管理。
逻辑结构如下所示：

![逻辑结构](Pasted%20image%2020240513154924.png)
物理结构如下所示：

![物理结构](Pasted%20image%2020240513155227.png)
## 数据库
## 数据表
### 物理结构
和通用数据库表结构设计类似
![数据表的物理结构](Pasted%20image%2020240513160803.png)
1. 默认8KB，最大32KB的数据页，每页结构为数据行，行指针（4B），页头文件(24B)；
2. 行指针永远指向当前页最新行数据；
3. 页头文件的主要成员变量如下：

| 名称          | 功能                  | 备注  |
| ----------- | ------------------- | --- |
| pd_lsn      | XLOG相关，实现WAL的相关底层结构 | 8B  |
| pd_checksum | 页面校验和               |     |
| pd_lower    | 行指针末尾位置             |     |
| pd_upper    | 最新数据的起始位置           |     |
| pd_special  | 索引页中使用，数据表页指向页尾     |     |

### 数据表读策略
1. 顺序扫描，即扫描全表
2. 索引扫描
3. TID扫描，ctid(块页号，行索引偏移量)
4. 位图扫描
5. 仅索引扫描
### 查询

查询执行的流程：
![查询流程](Pasted%20image%2020240513165235.png)
查询各阶段的详解：
1. 解析器，解析SQL文本内容，生成一棵语法解析树，供后续流程使用，并且解析器仅检查语法问题，不会考虑语义错误，如字段、表、索引不存在等。如下图就是一颗语法解析树![语法解析树](Pasted%20image%2020240513171634.png)
2. 分析器，对语法解析树进行语义分析，生成一棵查询树，此处会对字段、表、索引等进行语义检查。如下是一颗查询树：![查询树](Pasted%20image%2020240513173022.png)

3. 重写器，在需要时（如查询树中包含视图等）针对查询树会展开，根据规则系统（pg_rules）重新生成一棵查询树替换原查询树；
4. 计划器，基于代价来输出一个最优计划树。没有原生支持hint，需要pg_hint_plan插件拓展功能。
5. 执行器，按照计划树访问数据库与表的物理存储，获取结果


### 一次查询耗时的计算：
通用公式为：总代价=启动代价+运行代价。启动代价为在获取第一条数据元组之前的耗时，运行代价是指获取到全部数据元组的耗时。
1. 顺序扫描：顺序扫描直接扫数据表文件，所以启动代价为0。运行代价为
run_cost=cpu_run_cost + disk_run_cost
3. 索引扫描：