# Java基础
## Java平台的特点
### **一次书写，到处运行 `write once, run everywhere`** 
### 提供了`JVM-Java Virtual Machine`，以及对应的**自动垃圾回收机制 `GC- Garbage Collection` 来自动分配和释放内存
### 半解释性，半编译性的面向对象 `Object Oriented` 的强类型语言

1. Java本身并不像各种芯片指令集里的机器码那样强依赖于具体的硬件。依托于JVM的编译器，我们把Java源文件（.java文件）编译为二进制字节码文件（.class文件），然后通过JVM的类加载器将字节码文件装载到内存中进行解释执行，即翻译为对应机器的机器码。
2. 在发展过程中，JVM也已经支持[[热点代码]]的优化，即通过JIT（just in time）编译器来将热点代码直接编译成机器码。但是这个过程需要预热，运行时分析热点代码，所以一般在JVM启动之后一段时间，完成预热，系统会有更好的性能。
3. 在现在云原生时代的背景下，容器实际上代替了JVM的部分功能。这就要求这JVM需要以更短的时间来启动。于是乎AOT（ahead of time）编译器技术就发展起来了。它在程序启动前将Java字节码直接转化为可执行的机器码，来缩短JVM启动的时间，但是这块和Java自己支持的动态类加载功能是存在冲突的。所以以下这篇文章强烈推荐阅读解惑：   [云原生时代，Java的危与机_云原生_周志明_InfoQ精选文章](https://www.infoq.cn/article/rqfww2r2zpyqiolc1wbe)
## JRE与JDK
1. JRE，Java runtime environment 即Java运行时环境，包含了JVM以及Java类库
2. JDK，Java development kit 即Java开发套件，包含了JRE，以及一些分析、监测、统计工具 .列举常用工具如下： 
	2.1. javac 编译器命令行工具
	2.2. javap 反编译命令行工具
	2.3. jstack 打印当前JVM的线程快照信息，分析堆栈调用来解决一些类似死锁、资源耗尽等问题。
	2.4. jmap 远程和本机均可操作的命令行工具。用来打印jvm中内存的统计信息，常用于在发生OOM时打印内存dump
	2.5. jcmd 仅能用于JVM运行的同机器，也多用于打印dump
	2.6. JVisualVM 图形化的监控java应用工具，分析问题，排除故障
	2.7. Jconsole与JviualVM类似的图形化监控工具，也可命令行打开
	2.8. jstat 轻量级的小工具，用来监控heap size和垃圾回收情况
	2.9. jps 可以列出正在运行的Java虚拟机的进程信息的命令行工具
## JVM简析
### JVM的内存结构

![[20200522082651318.png]]
1. 堆-heap,线程共享的，并且所有的对象实例和数组均在上面分配内存。也是垃圾收集的主要目标

	1.1 新生代，包含eden区，from survivor区-S0区以及to survivor区-S1区。它是大部分对象创建和销毁的地方。在Eden区经过一次GC存活下来的对象会被拷贝到S0区，这个垃圾收集过程叫做minor GC，随后如果继续执行GC操作，那JVM会将Eden区、S0区的数据搬运到S1区。此时的垃圾收集过程叫做young GC.
	1.2 老年代，经过前几次的GC操作还存活的对象，以及较大对象会被直接分配到老年代。此处进行的垃圾收集被称之为full GC.

2. 方法区，也是线程共享的，主要存放运行时常量池，类加载的属性和方法以及JIT编译优化之后的代码
3. 虚拟机栈-VM stack，线程独有，存放当前方法所需的对象引用，局部变量表以及方法调用的栈帧
4. 本地方法栈-native stack,线程独有，与虚拟机栈类似，为虚拟机使用到的native方法服务
5. 程序计数器-PC register，线程独有，用来存储当前线程执行方法的JVM地址
### 垃圾收集
1. 实现自动垃圾收集的前提是需要确定哪些对象已经可以被收集然后释放。堆上的对象实例，方法区中的元数据都在选择范畴。
	1.1. 针对堆上的对象实例，存在引用计数和可达性分析两种解决思路。但是实际上引用计数存在循环引用的问题所以JVM并没有采纳。
	1.2. JVM选择的是可达性分析，或者叫做**追踪性垃圾收集**，它会选定活动对象作为GC roots，然后跟踪引用链条。如果被跟踪对象和GC roots之间没有链接可达，便可以认为这个对象已经是可以进行垃圾收集的对象。
2. 垃圾回收算法
	2.1. 复制算法 **copy** ，顺序拷贝存活的对象进行到新的内存地址，不会出现内存碎片，但需要预留空间。常见于minor GC或者说是young GC
	2.2. 标记-整理算法 **mark-compact**，标记出存活对象，并将其移动到新的内存地址用来放置，有效防止出现内存碎片。
	2.3. 标记-清除算法 **mark-sweep** ,标记存活对象，并将其清除，会出现内存碎片问题。
	2.4. 实际现在使用的GC算法都是复合型设计并且支持并行，并发。核心要点就是降低**stop-the-world**时间和提高GC的吞吐效率。

3. 常见垃圾收集器
	3.1. Serial GC，经典的单线程GC收集器。新生代采用复制，老年代采用标记-整理算法
	3.2. ParNew GC，新生代的GC实现，属于Serial GC的多线程版本。常与老年代老年代CMS GC搭配使用
	3.3. CMS GC，经典的并行GC，采用标记-清除的算法。意在减少STW时间，但是内存碎片化无法避免出现full GC,导致长时间停顿
	3.4. Parallel GC，是早期的JDK8 server模式的默认选择。特点是新生代、老年代并行的GC，吞吐量大
	3.5.[[ G1 GC]]，兼顾降低STW时间和提高吞吐量的设计，是JDK9之后的默认选择。大体设计概念是将内存划分为多个region，region之间为复制算法，但是整体上看还是标记-整理算法。

4. GC调优的一些思路
	4.1. 首先需要预设针对实际项目，GC调优的目的，到底是增加吞吐量，降低STW耗时，还是减少内存占用。大部分GC调优都是为了解决三个问题中的一个或者两个。
	4.2. 暴露问题，提出需求，定性的确定GC调优的目标。
	4.3. 掌握生产JVM和GC的实际情况，定位到具体的问题点，确认是否有调优必要。
	4.4. 通过之前的分析，对GC进行重新选型、调参。并做生产验证，如果没有达到预期再重复进行上述分析、整理、验证的步骤直到达到预期效果。

### Java的内存模型-JMM
如下图是Java线程之间通信的常用模式
![[v2-b098a84eb7598d70913444a991d1759b_r.png]]
用来控制Java线程之间的通信，或者说是保证线程之间的数据可见性
1. 指令重排是在多线程环境下优化代码效率，并且保证程序正确性的一种手段
2. 内存屏障，保证其他线程拿到某线程读写操作的值是最新的。
3. happen-before原则，包括但是不限于volatile、lock、synchronized等同步语义相关的关键字。
	3.1. 线程内执行的每个指令操作，都保证happen-before后面的指令操作，这是程序的顺序规定
	3.2. 对于volatile关键字修饰的变量，对它的写操作happen-before对于它的读操作
	3.3. 对于所有的解锁操作，happen-before于对应的加锁操作
	3.4. 对于对象的初始化操作，happen-before于对该对象的释放操作
	3.5. 对于线程内部操作的完成，happen-before于其他`thread.join()`的线程

## Java基本语法
### 面向对象的语言
1. 继承
2. 封装
3. 多态 
### 对象和基本数据类型
1. 八种基本数据类型包含字符型的byte/char，数字型的short/int/long/double/float，布尔型的boolean
2. 对象，万物皆对象，是对一类客观事物的属性和动作的一种抽象封装。
### 泛型
### 反射

### lambda表达式

## Java常用类库
### 集合
### BIO、NIO、AIO
### 并发-JUC
### 安全
### utils工具类相关
#### String
1. 常用基类，提供了构造、管理字符串的各种基本操作。但是被声明为final class，所以是immutable类型，于是针对它的拼接、修改都会新构造一个字符串，但是在系统中字符串操作又具有普遍性，所以相关操作的效率会显著影响应用性能。
2. StringBuffer，应运而生的的字符串处理类，不会产生中间String对象，只需要在原对象上进行字符串的拼接剪裁即可。并且也是线程安全的，指操作方法增加了`synchronized`。但是存在额外的性能开销。
3. StringBuilder，线程不安全的字符串处理类，又进一步降低了性能开销，速度更快。绝大部分情况下首选。

## 异常处理
![[accba531a365e6ae39614ebfa3273900.webp]]
1. 如上图所示，所有的error和exception都继承自throwable类，这也是Java设计出这一套异常处理的机制，仅有throwable才会作为异常、错误处理并捕获catch、抛出throw等。
2. error是会影响到Java程序正常运行，并且基本无法自动恢复的问题
3. 而exception是Java程序运行过程中可以预料的一些问题，并且可以被捕获并进行处理
	3.1. checked exception 受检异常如IO异常，并发中断异常等，需要在代码编写的时候显示处理，不然无法通过编译。
	3.2. unchecked exception 非受检异常、又叫做运行时异常如 空指针、数组越界等通常是可以避免的编码错误导致。
4. 针对异常处理的tips
	4.1. 不要泛泛直接捕获exception，需要处理具体的异常
	4.2. 不要将一大串代码直接用try-catch包裹住，找出其中最小的代码单元来进行包裹
	4.3. 也不要直接将堆栈信息打印出来，更适合的操作是输出到对应的日志框架中
	4.4. throw early, catch later 特别是在分布式的场景下，日志打印需要更多的信息，延后处理是一个比较好的方案
	4.5. catch住异常之后，要么打印日志，要么做相应的业务操作，不要直接吞掉异常
	